#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from my_robot_interfaces.srv import ArmCommand
from std_msgs.msg import Bool      
from std_srvs.srv import Trigger   
from pymycobot.mycobot320 import MyCobot320 
import threading 
import time
import math
import sys

# ===================== [ì„¤ì •] =====================
PORT = '/dev/ttyACM0'
BAUD = 115200
speed = 55
high = 255
POSE_WAIT = [-108.19, -37.17, 80.15, 40.81, -88.2, -19.07]

# [ê¸°ë³¸] PICK_ORIENTATION (ê°€ê¹Œìš¸ ë•Œ ê¸°ì¤€)
PICK_ORIENTATION_RX = -170
PICK_ORIENTATION_RY = -1.88

BOX_BASE_POSE = [-255.5, 43.4, 130.7, 177.43, 3.33, -0.89]
BOX_OFFSET_Y = -65.0 

# ì¶©ëŒ ê°ì§€ ì„ê³„ê°’ (mA)
COLLISION_THRESHOLD = 2500 

class ArmDriverNode(Node):
    def __init__(self):
        super().__init__('arm_driver_node')
        try:
            self.mc = MyCobot320(PORT, BAUD)
            time.sleep(0.5)
            self.mc.power_on()
            time.sleep(0.5)
            self.get_logger().info(f'âœ… MyCobot320 Connected on {PORT}')
        except Exception as e:
            self.get_logger().error(f'âŒ Connection Failed: {e}')
            return

        self.mutex = threading.Lock()
        
        # [Service] ë¡œë´‡ ë™ì‘ ëª…ë ¹
        self.srv = self.create_service(ArmCommand, '/arm/execute_cmd', self.handle_command)
        
        # [NEW] ì•ˆì „ ê´€ë ¨ êµ¬ë… ë° ì„œë¹„ìŠ¤
        self.fence_sub = self.create_subscription(Bool, '/fence_open', self.fence_callback, 10)
        self.safety_reset_srv = self.create_service(Trigger, '/arm/safety_reset', self.handle_safety_reset)

        # [NEW] ì•ˆì „ í”Œë˜ê·¸
        self.is_fence_open = False       
        self.is_waiting_for_code = False 
        
        self.pack_count = 0
        self.mc.set_color(0, 255, 0)
        
        self.init_gripper_sequence()

        # =========================================================================
        # [NEW] í„°ë¯¸ë„ ì…ë ¥ ê°ì‹œ ìŠ¤ë ˆë“œ (ì—”í„°í‚¤ í™•ì¸ìš©)
        # =========================================================================
        self.input_thread = threading.Thread(target=self.terminal_input_server, daemon=True)
        self.input_thread.start()
        
        print("\n" + "="*50)
        print("ğŸ“¢ [í„°ë¯¸ë„ ì¡°ì‘ ëª¨ë“œ í™œì„±í™”]")
        print("   ğŸ‘‰ [Enter] í‚¤: í˜„ì¬ ìƒíƒœ(ì „ì••/ì „ë¥˜/ê°ë„) ì¦‰ì‹œ í™•ì¸")
        print("   ğŸ‘‰ '1234' + [Enter]: ì•ˆì „ ì ê¸ˆ(íœìŠ¤) í•´ì œ")
        print("="*50 + "\n")

    # [ê¸°ëŠ¥ 1] í„°ë¯¸ë„ ì…ë ¥ ì²˜ë¦¬ í•¨ìˆ˜
    def terminal_input_server(self):
        while rclpy.ok():
            try:
                # ì‚¬ìš©ì ì…ë ¥ì„ ëŒ€ê¸° (ì—¬ê¸°ì„œ ì—”í„°ë¥¼ ì¹  ë•Œê¹Œì§€ ë©ˆì¶°ìˆìŒ)
                user_input = input().strip()
                
                if user_input == "":
                    # ì—”í„°ë§Œ ì³¤ì„ ë•Œ -> ìƒíƒœ ì¶œë ¥
                    self.log_motor_status_to_terminal()
                
                elif user_input == "1234":
                    # ì•ˆì „ í•´ì œ
                    if self.is_fence_open:
                        print("âš ï¸ íœìŠ¤ê°€ ì•„ì§ ì—´ë ¤ìˆìŠµë‹ˆë‹¤! ë‹«ì€ í›„ ì¬ì‹œë„í•˜ì„¸ìš”.")
                    else:
                        self.is_waiting_for_code = False
                        print("âœ… [OK] ì•ˆì „ ì ê¸ˆ í•´ì œ! ë™ì‘ì„ ì¬ê°œí•©ë‹ˆë‹¤.")
                        
            except EOFError:
                break
            except Exception as e:
                print(f"ì…ë ¥ ì˜¤ë¥˜: {e}")

    # í„°ë¯¸ë„ ì¶œë ¥ ì „ìš© ë¡œê·¸ í•¨ìˆ˜
    def log_motor_status_to_terminal(self):
        try:
            print("\nğŸ” [ì‹¤ì‹œê°„ ìƒíƒœ ì²´í¬]")
            volts = self.mc.get_servo_voltages()
            currents = self.mc.get_servo_currents()
            angles = self.mc.get_angles()
            status = self.mc.get_servo_status()
            
            if status: 
                self.get_logger().error(f"   ğŸ‘‰ Servo Status (Error Code): {status}")
            
            if volts:
                print(f"   âš¡ ì „ì••(V) : {volts}")
                if any(v < 22.0 for v in volts):
                    print("      âš ï¸ [ê²½ê³ ] ì „ì•• ë¶€ì¡±! ì–´ëŒ‘í„° í™•ì¸ ìš”ë§")
            else:
                print("   âš¡ ì „ì••(V) : í†µì‹  ì‹¤íŒ¨")

            if currents:
                print(f"   ğŸ”Œ ì „ë¥˜(mA): {currents}")
            else:
                print("   ğŸ”Œ ì „ë¥˜(mA): í†µì‹  ì‹¤íŒ¨")

            if angles:
                print(f"   ğŸ“ ê°ë„(deg): {angles}")
            
            print("-" * 30)

        except Exception as e:
            print(f"âŒ ìƒíƒœ ì¡°íšŒ ì‹¤íŒ¨: {e}")

    # [NEW] íœìŠ¤ ì‹ í˜¸ ì½œë°±
    def fence_callback(self, msg):
        if msg.data: # True = íœìŠ¤ ì—´ë¦¼ (ìœ„í—˜)
            if not self.is_fence_open:
                self.get_logger().fatal("ğŸš¨ [EMERGENCY] FENCE OPEN! Stopping Robot.")
                self.mc.stop() 
                self.is_fence_open = True
                self.is_waiting_for_code = True 
        else: # False = íœìŠ¤ ë‹«í˜
            if self.is_fence_open:
                self.get_logger().warn("ğŸ”’ Fence Closed. Waiting for code '1234' to resume...")
                self.is_fence_open = False
                
    def handle_safety_reset(self, request, response):
        if self.is_fence_open:
            response.success = False
            response.message = "Cannot reset while fence is still OPEN!"
        else:
            self.is_waiting_for_code = False
            self.get_logger().info("âœ… Safety Lock Released via Code. Resuming...")
            response.success = True
            response.message = "Resumed"
        return response

    def init_gripper_sequence(self):
        try:
            self.get_logger().info("ğŸ”§ Initializing Gripper...")
            self.mc.set_gripper_mode(0)
            self.mc.init_electric_gripper()
            time.sleep(1.0)
            self.get_logger().info("âœ… Gripper Initialized")
        except Exception as e:
            self.get_logger().error(f"âš ï¸ Gripper Init Warning: {e}")

    def log_motor_status(self):
        # ê¸°ì¡´ ROS ë¡œê·¸ìš© í•¨ìˆ˜ (ì—ëŸ¬ ë°œìƒ ì‹œ ì‚¬ìš©)
        self.log_motor_status_to_terminal()

    # [ìˆ˜ì •] ëª©í‘œ ë„ì°© ë° ì•ˆì „ ì •ì§€ í™•ì¸ í•¨ìˆ˜
    def wait_until_arrival(self, target, mode='coords', tol=5.0, timeout=15):
        start = time.time()
        last_values = None
        stop_count = 0
        was_paused = False

        time.sleep(0.2) 

        while time.time() - start < timeout:
            # ================= ì•ˆì „ ì •ì§€ ë¡œì§ =================
            if self.is_fence_open or self.is_waiting_for_code:
                if not was_paused:
                    self.mc.stop()
                    self.get_logger().warn("â¸ï¸ Robot PAUSED (Safety Trigger). Waiting...")
                    was_paused = True
                time.sleep(0.5)
                start += 0.5 
                continue 
            
            if was_paused:
                self.get_logger().info("â–¶ï¸ Resuming Movement...")
                if mode == 'coords':
                    self.mc.send_coords(target, speed, 0)
                else:
                    self.mc.send_angles(target, speed)
                was_paused = False
                time.sleep(0.5)

            # 1. ì¶©ëŒ ê°ì§€
            try:
                currents = self.mc.get_servo_currents()
                if isinstance(currents, list) and len(currents) == 6:
                    if max(currents) > COLLISION_THRESHOLD:
                        self.mc.stop()
                        raise RuntimeError(f"ğŸš¨ ì¶©ëŒ ê°ì§€! (Current: {max(currents)}mA)")
            except RuntimeError as re:
                raise re
            except Exception:
                pass 

            # 2. í˜„ì¬ê°’ ì½ê¸°
            try:
                if mode == 'coords':
                    current = self.mc.get_coords()
                else:
                    current = self.mc.get_angles()
            except Exception:
                continue

            if not current or len(current) != 6:
                continue

            # 3. ëª©í‘œ ì§€ì  ë„ì°© í™•ì¸
            diff = max([abs(c - t) for c, t in zip(current, target)])
            if diff < tol:
                return True 
            
            # 4. ì›€ì§ì„ ì •ì§€ í™•ì¸
            if last_values:
                move_diff = max([abs(c - l) for c, l in zip(current, last_values)])
                if move_diff < 1.0: 
                    stop_count += 1
                else:
                    stop_count = 0
            
            # =================================================================
            # [ê¸°ëŠ¥ 2] ì˜¤ì°¨ê°€ ë„ˆë¬´ í¬ë©´ ì‹¤íŒ¨ ì²˜ë¦¬ (50.0 ì´ìƒ)
            # =================================================================
            if stop_count > 5:
                # ë©ˆì·„ëŠ”ë° ì˜¤ì°¨ê°€ 50ì´ ë„˜ìœ¼ë©´ ì´ê±´ ë„ì°©ì´ ì•„ë‹ˆë¼ ì‚¬ê³ ì„
                if diff >= 50.0:
                    err_msg = f"âŒ [FATAL ERROR] ë¡œë´‡ ì •ì§€ë¨. ê·¸ëŸ¬ë‚˜ ì˜¤ì°¨({diff:.1f})ê°€ í—ˆìš©ë²”ìœ„(50) ì´ˆê³¼!"
                    self.get_logger().fatal(err_msg)
                    self.log_motor_status_to_terminal() # ì¦‰ì‹œ ìƒíƒœ ì¶œë ¥
                    raise RuntimeError(err_msg) # ì—¬ê¸°ì„œ ì—ëŸ¬ë¥¼ ë„ì›Œ ë©ˆì¶¤
                
                else:
                    self.get_logger().warn(f"âš ï¸ ëª©í‘œ ì˜¤ì°¨({diff:.1f})ê°€ ìˆì§€ë§Œ í—ˆìš©ë²”ìœ„(50) ì´ë‚´ë¼ ì§„í–‰í•¨.")
                    return True

            last_values = current
            time.sleep(0.1)
        
        # íƒ€ì„ì•„ì›ƒ
        err_msg = f"â³ [TIMEOUT] ëª©í‘œ ë„ë‹¬ ì‹¤íŒ¨! (Mode: {mode}, Final Diff: {diff:.1f})"
        self.get_logger().fatal(err_msg)
        raise TimeoutError(err_msg)
    
    def handle_command(self, request, response):
        with self.mutex:
            # ì¶œë°œ ì „ ì „ì•• ê²€ì‚¬
            try:
                volts = self.mc.get_servo_voltages()
                if volts and any(v < 20.0 for v in volts):
                    msg = f"âŒ ì „ì•• ë¶€ì¡±! (Current Volts: {volts})"
                    self.get_logger().fatal(msg)
                    response.success = False
                    response.message = msg
                    return response
            except Exception:
                pass 
            
            command = request.command
            target = request.target_coord 
            
            self.get_logger().info(f"Command Received: {command}")
            self.mc.set_color(0, 0, 255) 

            try:
                if command == "home":
                    self.get_logger().info("ğŸ  Moving to WAIT Position...")
                    self.mc.send_angles(POSE_WAIT, speed)
                    self.wait_until_arrival(POSE_WAIT, mode='angles', tol=3.0)
                    
                    self.init_gripper_sequence()
                    self.mc.set_gripper_value(100, 20, 1) 
                    time.sleep(1.0) 

                    self.mc.set_color(0, 255, 0)
                    response.success = True
                    response.message = "Robot Ready (WAIT)"
                
                elif command == "pick_good":
                    x, y, raw_angle = target[0], target[1], target[2]
                    
                    # ê°ë„ ê³„ì‚°
                    final_grip_yaw = (raw_angle + 45) % 90 - 45
                    
                    # [1ë‹¨ê³„] ìƒê³µ ì´ë™
                    target_pose = [x, y, high, -175.0, 0, 0] 
                    self.get_logger().info(f"ğŸš€ [1] ìœ„ì¹˜ ì´ë™: {target_pose}")
                    self.mc.send_coords(target_pose, speed, 0)
                    self.wait_until_arrival(target_pose, mode='coords', tol=5.0)

                    # [2ë‹¨ê³„] íšŒì „
                    self.get_logger().info(f"ğŸ”„ [2] ê·¸ë¦¬í¼ íšŒì „: {final_grip_yaw}ë„")
                    self.mc.send_angle(6, final_grip_yaw, speed)
                    time.sleep(0.5) 
                    
                    # [3ë‹¨ê³„] í•˜ê°•
                    current_coords = self.mc.get_coords()
                    if not current_coords:
                        descent_pose = [x, y, high - 40, -175, 0, 0]
                    else:
                        descent_pose = list(current_coords)
                        descent_pose[2] = high - 40
                    
                    self.get_logger().info(f"â¬‡ï¸ [3] í•˜ê°•: {descent_pose}")
                    self.mc.send_coords(descent_pose, speed, 0)
                    self.wait_until_arrival(descent_pose, mode='coords', tol=5.0)

                    # [4ë‹¨ê³„] ì¡ê¸°
                    self.get_logger().info("âœŠ ê·¸ë¦¬í¼ ë‹«ê¸°")
                    self.mc.set_gripper_value(30, 20, 1) 
                    time.sleep(1.5)

                    # [5ë‹¨ê³„] ìƒìŠ¹ & ì´ë™
                    SAFE_Z_HEIGHT = high + 40
                    waypoint = list(descent_pose)
                    waypoint[0] *= 0.6
                    waypoint[1] *= 0.6
                    waypoint[2] = SAFE_Z_HEIGHT
                    
                    self.get_logger().info(f"â†—ï¸ ë‹¹ê²¨ì„œ ì˜¬ë¦¬ê¸°")
                    self.mc.send_coords(waypoint, speed, 0)
                    self.wait_until_arrival(waypoint, mode='coords', tol=10.0)

                    # [6ë‹¨ê³„] ì ì¬
                    final_place_pose = list(BOX_BASE_POSE) 
                    final_place_pose[1] = BOX_BASE_POSE[1] + (self.pack_count * BOX_OFFSET_Y)
                    
                    hover_place_pose = list(final_place_pose)
                    hover_place_pose[2] = SAFE_Z_HEIGHT  
                    
                    self.get_logger().info("âœˆï¸ ì ì¬ ìœ„ì¹˜ ìƒê³µ")
                    self.mc.send_coords(hover_place_pose, speed, 0)
                    self.wait_until_arrival(hover_place_pose, mode='coords', tol=5.0)

                    self.get_logger().info("â¬‡ï¸ ë°•ìŠ¤ ì•ˆìœ¼ë¡œ í•˜ê°•")
                    self.mc.send_coords(final_place_pose, speed, 0)
                    self.wait_until_arrival(final_place_pose, mode='coords', tol=5.0)
                    
                    # [7ë‹¨ê³„] ë†“ê¸°
                    self.mc.set_gripper_value(100, 20, 1) 
                    time.sleep(1.0)
                    
                    self.get_logger().info("â¬†ï¸ ë³µê·€ ìƒìŠ¹")
                    self.mc.send_coords(hover_place_pose, speed, 0)
                    self.wait_until_arrival(hover_place_pose, mode='coords', tol=5.0)

                    self.pack_count += 1
                    if self.pack_count >= 3:
                        self.pack_count = 0 

                    self.get_logger().info("ğŸ  í™ˆìœ¼ë¡œ ë³µê·€")
                    self.mc.send_angles(POSE_WAIT, speed)
                    self.wait_until_arrival(POSE_WAIT, mode='angles', tol=3.0)

                    response.success = True
                    response.message = f"Done (Count: {self.pack_count})"

                elif command == "discard_bad":
                    response.success = True
                    response.message = "Discarded"
                
                self.mc.set_color(0, 255, 0)

            except Exception as e:
                self.mc.set_color(255, 0, 0) 
                response.success = False
                response.message = str(e)
                self.get_logger().fatal(f"ğŸ›‘ ì‘ì—… ì¤‘ë‹¨ ë° ì§„ë‹¨: {e}")
                self.log_motor_status_to_terminal()
            
            return response

def main(args=None):
    rclpy.init(args=args)
    node = ArmDriverNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        if hasattr(node, 'mc'):
            try:
                node.mc.stop()
            except Exception:
                pass
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
