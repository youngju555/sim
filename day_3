// ì´ˆìŒíŒŒ ì„¼ì„œë¡œ ì‚¬ëŒì„ ê°ì§€í•´ì„œ ë¶€ì €ë¥¼ ìš¸ë¦¬ê³  ì„œë¸Œ ëª¨í„°ë¥¼ í™œìš©í•´ ìŠ¤í‹±ì„ ë‹¬ì•„ì„œ ìŠ¤í‹±ì„ ì›€ì§ì´ë©° íƒ€ê²©í•˜ëŠ” RCì¹´ ì œì‘. ë¸”ë£¨íˆ¬ìŠ¤ë¡œ ì¡°ì¢…í•˜ë©° RCì¹´ë¥¼ ì‚¬ëŒì„ ì«“ì•„ê°€ë©° íƒ€ê²©í•˜ê²Œ ì œì‘.

#include <Servo.h>  

// í•€ ì •ì˜
#define ENCODER_LEFT 2
#define ENCODER_RIGHT 3

#define IR_LEFT 4
#define IR_RIGHT 8

#define SERVO_PIN 9
#define BUZZER 13

#define ULTRASONIC_TRIG 12
#define ULTRASONIC_ECHO 7

#define MOTOR_LEFT_1 5
#define MOTOR_LEFT_2 6
#define MOTOR_RIGHT_1 10
#define MOTOR_RIGHT_2 11

// ì—”ì½”ë”ìš© ë³€ìˆ˜
volatile int countLeft = 0;
volatile int countRight = 0;

// ì„œë³´
Servo swatter;

// ê¸°ë³¸ ì„¤ì •
char command;
long duration;
int distance;

void setup() {
  Serial.begin(9600);

  // ì„œë³´
  swatter.attach(SERVO_PIN);
  swatter.write(90); // ì´ˆê¸° ìœ„ì¹˜

  // ë¶€ì €
  pinMode(BUZZER, OUTPUT);

  // ì´ˆìŒíŒŒ
  pinMode(ULTRASONIC_TRIG, OUTPUT);
  pinMode(ULTRASONIC_ECHO, INPUT);

  // ì—”ì½”ë”
  pinMode(ENCODER_LEFT, INPUT_PULLUP);
  pinMode(ENCODER_RIGHT, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(ENCODER_LEFT), countLeftEncoder, RISING);
  attachInterrupt(digitalPinToInterrupt(ENCODER_RIGHT), countRightEncoder, RISING);

  // ëª¨í„° í•€
  pinMode(MOTOR_LEFT_1, OUTPUT);
  pinMode(MOTOR_LEFT_2, OUTPUT);
  pinMode(MOTOR_RIGHT_1, OUTPUT);
  pinMode(MOTOR_RIGHT_2, OUTPUT);
}

void loop() {
  // Bluetooth ëª…ë ¹ ìˆ˜ì‹ 
  if (Serial.available()) {
    command = Serial.read();
    handleCommand(command);
  }

  // ì´ˆìŒíŒŒ ê°ì§€
  distance = getDistance();
  if (distance > 0 && distance < 30) {
    alertAndSwat(); // ë¶€ì € + íŒŒë¦¬ì±„ íœ˜ë‘ë¥´ê¸°
  }

  delay(50);
}

// ğŸ“ ê±°ë¦¬ ì¸¡ì • í•¨ìˆ˜
int getDistance() {
  digitalWrite(ULTRASONIC_TRIG, LOW);
  delayMicroseconds(2);
  digitalWrite(ULTRASONIC_TRIG, HIGH);
  delayMicroseconds(10);
  digitalWrite(ULTRASONIC_TRIG, LOW);
  duration = pulseIn(ULTRASONIC_ECHO, HIGH, 20000);
  if (duration == 0) return -1; // ì‹¤íŒ¨ ì‹œ
  return duration * 0.034 / 2;
}

// ğŸ”” ì‚¬ëŒ ê°ì§€ ì‹œ í–‰ë™
void alertAndSwat() {
  tone(BUZZER, 1000, 300); // ë¶€ì € ìš¸ë¦¼
  swatter.write(0); // íŒŒë¦¬ì±„ íœ˜ë‘ë¥´ê¸°
  delay(300);
  swatter.write(90); // ì›ìœ„ì¹˜
  delay(500);
}

// ğŸ® ì¡°ì‘ ëª…ë ¹ ì²˜ë¦¬
void handleCommand(char cmd) {
  switch (cmd) {
    case 'F': moveForward(); break;
    case 'B': moveBackward(); break;
    case 'L': turnLeft(); break;
    case 'R': turnRight(); break;
    case 'S': stopMotors(); break;
  }
}

// âš™ï¸ ëª¨í„° ì œì–´ í•¨ìˆ˜ë“¤
void moveForward() {
  countLeft = 0; countRight = 0;
  analogWrite(MOTOR_LEFT_1, 150); digitalWrite(MOTOR_LEFT_2, LOW);
  analogWrite(MOTOR_RIGHT_1, 150); digitalWrite(MOTOR_RIGHT_2, LOW);

  while (abs(countLeft - countRight) < 5 && (countLeft < 30 && countRight < 30)) {
    if (countLeft > countRight) {
      analogWrite(MOTOR_LEFT_1, 130);
      analogWrite(MOTOR_RIGHT_1, 150);
    } else if (countRight > countLeft) {
      analogWrite(MOTOR_LEFT_1, 150);
      analogWrite(MOTOR_RIGHT_1, 130);
    } else {
      analogWrite(MOTOR_LEFT_1, 150);
      analogWrite(MOTOR_RIGHT_1, 150);
    }
  }

  stopMotors();
}

void moveBackward() {
  analogWrite(MOTOR_LEFT_1, LOW); analogWrite(MOTOR_LEFT_2, 150);
  analogWrite(MOTOR_RIGHT_1, LOW); analogWrite(MOTOR_RIGHT_2, 150);
}

void turnLeft() {
  analogWrite(MOTOR_LEFT_1, LOW); analogWrite(MOTOR_LEFT_2, 150);
  analogWrite(MOTOR_RIGHT_1, 150); digitalWrite(MOTOR_RIGHT_2, LOW);
}

void turnRight() {
  analogWrite(MOTOR_LEFT_1, 150); digitalWrite(MOTOR_LEFT_2, LOW);
  analogWrite(MOTOR_RIGHT_1, LOW); analogWrite(MOTOR_RIGHT_2, 150);
}

void stopMotors() {
  analogWrite(MOTOR_LEFT_1, 0); analogWrite(MOTOR_LEFT_2, 0);
  analogWrite(MOTOR_RIGHT_1, 0); analogWrite(MOTOR_RIGHT_2, 0);
}

// ğŸŒ€ ì—”ì½”ë” ì¸í„°ëŸ½íŠ¸ í•¨ìˆ˜
void countLeftEncoder() {
  countLeft++;
}

void countRightEncoder() {
  countRight++;
}

espìš© ì½”ë“œ
#include <HardwareSerial.h>
#include <ESP32Servo.h>

// í•€ ì„¤ì •
#define SERVO_PIN 18
#define BUZZER_PIN 19
#define ULTRASONIC_TRIG 5
#define ULTRASONIC_ECHO 17

// ì„œë³´
Servo swatter;

// ì‹œë¦¬ì–¼ í†µì‹ ìš©
HardwareSerial ArduinoSerial(2); // UART2

// ì„¼ì„œê°’
int irLeft = 0;
int irRight = 0;

void setup() {
  Serial.begin(9600);           // ESP32 ë””ë²„ê¹…ìš©
  ArduinoSerial.begin(9600, SERIAL_8N1, 16, 17); // RX=16, TX=17

  // ì„œë³´ ì„¤ì •
  swatter.setPeriodHertz(50);
  swatter.attach(SERVO_PIN, 500, 2400);
  swatter.write(90);  // ì´ˆê¸° ìœ„ì¹˜

  // ë¶€ì €, ì´ˆìŒíŒŒ í•€ ì„¤ì •
  pinMode(BUZZER_PIN, OUTPUT);
  pinMode(ULTRASONIC_TRIG, OUTPUT);
  pinMode(ULTRASONIC_ECHO, INPUT);
}

void loop() {
  // ğŸ“¥ ì•„ë‘ì´ë…¸ì—ì„œ IR ì„¼ì„œê°’ ìˆ˜ì‹ 
  if (ArduinoSerial.available()) {
    String data = ArduinoSerial.readStringUntil('\n');
    data.trim();

    // ì˜ˆì‹œ: "L1 R0" í˜•ì‹ì´ë©´
    if (data.startsWith("L") && data.indexOf("R") > 0) {
      irLeft = data.charAt(1) - '0';
      irRight = data.charAt(data.indexOf("R") + 1) - '0';
    }
  }

  // ğŸ‘€ ì´ˆìŒíŒŒ ê°ì§€
  int dist = getDistance();
  if (dist > 0 && dist < 30) {
    alertAndSwat();
  }

  delay(100);
}

int getDistance() {
  digitalWrite(ULTRASONIC_TRIG, LOW);
  delayMicroseconds(2);
  digitalWrite(ULTRASONIC_TRIG, HIGH);
  delayMicroseconds(10);
  digitalWrite(ULTRASONIC_TRIG, LOW);

  long duration = pulseIn(ULTRASONIC_ECHO, HIGH, 20000);
  if (duration == 0) return -1;
  return duration * 0.034 / 2;
}

void alertAndSwat() {
  tone(BUZZER_PIN, 1000, 300);
  swatter.write(0);
  delay(300);
  swatter.write(90);
  delay(500);
}
