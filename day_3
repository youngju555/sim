// ì´ˆìŒíŒŒ ì„¼ì„œë¡œ ì‚¬ëŒì„ ê°ì§€í•´ì„œ ë¶€ì €ë¥¼ ìš¸ë¦¬ê³  ì„œë¸Œ ëª¨í„°ë¥¼ í™œìš©í•´ ìŠ¤í‹±ì„ ë‹¬ì•„ì„œ ìŠ¤í‹±ì„ ì›€ì§ì´ë©° íƒ€ê²©í•˜ëŠ” RCì¹´ ì œì‘. ë¸”ë£¨íˆ¬ìŠ¤ë¡œ ì¡°ì¢…í•˜ë©° RCì¹´ë¥¼ ì‚¬ëŒì„ ì«“ì•„ê°€ë©° íƒ€ê²©í•˜ê²Œ ì œì‘.

#include <ESP32Servo.h>  // Servo.h ëŒ€ì‹  ESP32 ì „ìš© ë¼ì´ë¸ŒëŸ¬ë¦¬

// í•€ ì •ì˜
#define ENCODER_LEFT 2
#define ENCODER_RIGHT 3

#define IR_LEFT 4
#define IR_RIGHT 8

#define SERVO_PIN 9
#define BUZZER 13

#define ULTRASONIC_TRIG A2
#define ULTRASONIC_ECHO A3

#define MOTOR_LEFT_1 5
#define MOTOR_LEFT_2 6
#define MOTOR_RIGHT_1 10
#define MOTOR_RIGHT_2 11

// ì—”ì½”ë”ìš© ë³€ìˆ˜
volatile int countLeft = 0;
volatile int countRight = 0;

// ì„œë³´
Servo swatter;

// ê¸°ë³¸ ì„¤ì •
char command;
long duration;
int distance;

void setup() {
  Serial.begin(9600);

  // ì„œë³´
  swatter.setPeriodHertz(50);                    // ì„œë³´ìš© PWM ì£¼íŒŒìˆ˜ ì„¤ì •
  swatter.attach(SERVO_PIN, 500, 2400);          // attach(pin, minPulse, maxPulse)
  swatter.write(90);                             // ëŒ€ê¸° ìì„¸

  // ë¶€ì €
  pinMode(BUZZER, OUTPUT);

  // ì´ˆìŒíŒŒ
  pinMode(ULTRASONIC_TRIG, OUTPUT);
  pinMode(ULTRASONIC_ECHO, INPUT);

  // ì—”ì½”ë”
  pinMode(ENCODER_LEFT, INPUT_PULLUP);
  pinMode(ENCODER_RIGHT, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(ENCODER_LEFT), countLeftEncoder, RISING);
  attachInterrupt(digitalPinToInterrupt(ENCODER_RIGHT), countRightEncoder, RISING);

  // ëª¨í„° í•€
  pinMode(MOTOR_LEFT_1, OUTPUT);
  pinMode(MOTOR_LEFT_2, OUTPUT);
  pinMode(MOTOR_RIGHT_1, OUTPUT);
  pinMode(MOTOR_RIGHT_2, OUTPUT);
}

void loop() {
  // Bluetooth ëª…ë ¹ ìˆ˜ì‹ 
  if (Serial.available()) {
    command = Serial.read();
    handleCommand(command);
  }

  // ì´ˆìŒíŒŒ ê°ì§€
  distance = getDistance();
  if (distance > 0 && distance < 30) {
    alertAndSwat(); // ë¶€ì € + íŒŒë¦¬ì±„ íœ˜ë‘ë¥´ê¸°
  }

  delay(50);
}

// ğŸ“ ê±°ë¦¬ ì¸¡ì • í•¨ìˆ˜
int getDistance() {
  digitalWrite(ULTRASONIC_TRIG, LOW);
  delayMicroseconds(2);
  digitalWrite(ULTRASONIC_TRIG, HIGH);
  delayMicroseconds(10);
  digitalWrite(ULTRASONIC_TRIG, LOW);
  duration = pulseIn(ULTRASONIC_ECHO, HIGH, 20000);
  if (duration == 0) return -1; // ì‹¤íŒ¨ ì‹œ
  return duration * 0.034 / 2;
}

// ğŸ”” ì‚¬ëŒ ê°ì§€ ì‹œ í–‰ë™
void alertAndSwat() {
  tone(BUZZER, 1000, 300); // ë¶€ì € ìš¸ë¦¼
  swatter.write(0);        // íŒŒë¦¬ì±„ íœ˜ë‘ë¥´ê¸°
  delay(300);
  swatter.write(90);       // ì›ìœ„ì¹˜
  delay(500);
}

// ğŸ® ì¡°ì‘ ëª…ë ¹ ì²˜ë¦¬
void handleCommand(char cmd) {
  switch (cmd) {
    case 'F': moveForward(); break;
    case 'B': moveBackward(); break;
    case 'L': turnLeft(); break;
    case 'R': turnRight(); break;
    case 'S': stopMotors(); break;
  }
}

// âš™ï¸ ëª¨í„° ì œì–´ í•¨ìˆ˜ë“¤
void moveForward() {
  countLeft = 0; countRight = 0;
  analogWrite(MOTOR_LEFT_1, 150); digitalWrite(MOTOR_LEFT_2, LOW);
  analogWrite(MOTOR_RIGHT_1, 150); digitalWrite(MOTOR_RIGHT_2, LOW);

  // ì—”ì½”ë” ê°’ ë™ê¸°í™” â†’ 30íšŒì „ë§ˆë‹¤ ë©ˆì¶”ê¸° ì˜ˆì‹œ
  while (abs(countLeft - countRight) < 5 && (countLeft < 30 && countRight < 30)) {
    if (countLeft > countRight) {
      analogWrite(MOTOR_LEFT_1, 130);
      analogWrite(MOTOR_RIGHT_1, 150);
    } else if (countRight > countLeft) {
      analogWrite(MOTOR_LEFT_1, 150);
      analogWrite(MOTOR_RIGHT_1, 130);
    } else {
      analogWrite(MOTOR_LEFT_1, 150);
      analogWrite(MOTOR_RIGHT_1, 150);
    }
  }

  stopMotors();
}

void moveBackward() {
  analogWrite(MOTOR_LEFT_1, LOW); analogWrite(MOTOR_LEFT_2, 150);
  analogWrite(MOTOR_RIGHT_1, LOW); analogWrite(MOTOR_RIGHT_2, 150);
}

void turnLeft() {
  analogWrite(MOTOR_LEFT_1, LOW); analogWrite(MOTOR_LEFT_2, 150);
  analogWrite(MOTOR_RIGHT_1, 150); digitalWrite(MOTOR_RIGHT_2, LOW);
}

void turnRight() {
  analogWrite(MOTOR_LEFT_1, 150); digitalWrite(MOTOR_LEFT_2, LOW);
  analogWrite(MOTOR_RIGHT_1, LOW); analogWrite(MOTOR_RIGHT_2, 150);
}

void stopMotors() {
  analogWrite(MOTOR_LEFT_1, 0); analogWrite(MOTOR_LEFT_2, 0);
  analogWrite(MOTOR_RIGHT_1, 0); analogWrite(MOTOR_RIGHT_2, 0);
}

// ğŸŒ€ ì—”ì½”ë” ì¸í„°ëŸ½íŠ¸ í•¨ìˆ˜
void countLeftEncoder() {
  countLeft++;
}

void countRightEncoder() {
  countRight++;
}
